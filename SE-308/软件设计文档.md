# 软件设计文档


## 前端

### 技术选型理由



### 架构设计




### 模块划分






### 软件设计技术






## 后端

### 技术选型理由

以下讲述了项目技术选型的考虑因素：

1. **安全性**：我们希望程序运行过程中可以保证内存安全与线程安全，降低开发人员心智负担与运行维护成本。
2. **可维护性**：可维护性较好的代码可以让团队中的开发人员更容易理解，提高团队工作效率并减少代码出错的可能。
3. **软件性能**：软件应具有较高的运行速度，支持足够高的并发数量，在高压力下也维持一定的可用性
4. **效率**：软件开发应具有较高效率，为此需要降低开发整体的复杂性，选择适用于团队的技术

根据以上考虑因素，我们的技术选型如下：

1. **语言**：出于开发效率考虑，项目起始时我们对编程语言的选择主要有 Rust，Golang，JavaScript 等，出于运行速度的原因排除了 JavaScript, Python 等非 Native 语言，最后在 Golang 与 Rust 中选择了 Rust 的原因是 Rust 提供了更多优秀的语言特性、更快的运行速度以及优秀的编译时检查和更高的安全性，从而减少运行时 Debug 的难度。虽然 Rust 的学习曲线可能较为陡峭，但是整体来看是对有利于提升项目产品质量的，提高整体开发效率的。
2. **Web 框架**：在 Rust 语言中可选的 web 框架有 Actix-web, Rocket, warp 等。我们最后选择 Actix-web 的原因是其不需要使用 Nightly 版本的编译器，有着更加好的社区支持，有效利用了异步特性，并在 [benchmark](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=query) 中有很高的排名。
3. **ORM**：我们选择使用了 diesel ORM 来提供 MySQL 关系数据库的访问，选择的原因是 diesel 提供了便利且类型安全的数据库访问，并可简化部署时数据库迁移的工作。带来的缺点是由于 diesel 没有使用异步数据库驱动，可能会拖慢框架速度，这点也可在框架 benchmark 中看到。
4. **Docker**：我们选择了使用 Docker Compose 来进行程序的部署，通过 docker compose 可以方便地在服务器上设置必须的信息后一键部署，减少配置环境的麻烦。缺点是由于 Rust 语言编译时间较长，且 `crates.io` 在国内连接较差，需要通过阿里云的海外容器构建服务来进行容器构建，增长了每次更新所需要的时间。
5. **Web 服务器**：我们选择 Caddy 作为 Web 服务器，在项目中 Caddy 主要的用途是对程序的业务请求进行反向代理。相较于 NGINX，Caddy 提供了更简单的配置编写、更方便开启 HTTPS 的特点，利于快速的服务器部署。
6. **文本搜索**：在我们的项目中需要对用户任务的信息进行搜索，这方面我选用 Tantivy 库进行实现，它提供了许多类似于在 Java 项目中常用的 Lucene 库的功能。并通过结巴分词实现对中文文本的快速的搜索。


### 架构设计

#### 鉴权

由于服务端实际上接受的请求来自于奶牛用户，以及学生用户，所以不同种类的用户存在公用的API接口，也存在部分双方私有的API接口。并且，游客用户(即未注册登录的用户)不能使用大部分的功能API。考虑到这样的鉴权需要，须设定一个简单有效的鉴权方案。
服务端在路由层中为不同接口指定鉴权权限，并且根据权限系数进行API权限划分：

1. `CommonAPI` ：公用API接口
2. `CowAPI`：奶牛专用API接口
3. `StudentAPI`：学生专用API接口
4. `BasicAPI`：游客与用户均可使用API接口


#### 多核计算资源

在技术选型时，我们使用Rust语言进行服务端系统编写，同时结合其异步框架actix_web进行服务端的整体搭建，该框架所构成的服务端并行响应I/O请求速度较为优异，可以视作是一个比较有效的并行架构，一定程度上充分利用的服务器的多核计算资源，解决了负载均衡的问题。


#### 可扩展的架构

后端的整体构建参考MC结构，Model层交由数据库开发人员进行，Controller层交由服务端开发人员进行，分层结构显著，存在可扩展性。
在原本的MC架构上，添加了路由层`Router`，服务层`Service`，不同层负责的权职如下：

* `Router`：路由层，根据前端访问的API路径，路由到控制层的具体处理函数中
* `Controller`：控制层，处理HTTPS请求，收集请求参数，根据权限系数判断请求合法性，并调用服务层的对应函数
* `Service`：服务层，与数据库层进行交互，处理业务逻辑
* `Model`：数据库层，负责管理数据库内容


#### 自动化测试与部署

结合curl工具，编写测试脚本进行服务端接口单元测试；部署采用docker工具进行，具体过程请关注部署文档。
由于源码托管在`GItHub`，因此采用`Travis CI`进行持续的自动化测试



### 模块划分

在后端模块划分上主要分为：API 模块，业务逻辑模块，数据库模块，信息搜索模块以及用户验证模块，其内容分别如下：

1. **API 模块**：实现 API 设计中指定的 API，根据 API 请求调用业务逻辑中对应的操作。其部分位于 emtm-web crate 下的 route 模块。
2. **业务逻辑模块**：实现软件中的主要业务逻辑，根据请求进行对应的操作，并将结果返回给用户。位于 emtm-web 下的 control 模块。
3. **数据库模块**：负责数据库结构的定义与数据库数据与程序对象的转换。由 emtm-db crate下的 controller, db_models 和 models 模块组成。
4. **信息搜索模块**：负责对用户发起的搜索请求进行处理，通过索引获得相应内容在数据库中的位置，以返回正确的搜索内容信息。位于emtm-db 下的 search 模块。
5. **用户验证模块**：根据用户上传的验证图片，调用相应的腾讯 AI 平台提供的图像识别接口进行识别，根据识别结果决定验证是否通过。位于 emtm-verify crate 中。

### 软件设计技术

1. **Object-Oriented Programming**: 在项目整体中有较广的使用，例如数据库中的controller，models 和 db_models 模块。虽然我们使用的 Rust 语言许多方面与传统的面向对象语言不同，但仍然可以通过 trait 与 struct 来实现封装、多态等面向对象特性，并借助编译器提供的零开销抽象的特性高效地获得代码复用、易于理解、高扩展性等好处。
2. **设计模式**：
   - *单例模式*：在 emtm-db 的 search模组中应用，定义了全局唯一的 searcher 对象，在第一次使用时进行初始化，使用单例模式的原因是建立信息索引的开销较大，若每次新增信息都进行索引变更将拖慢软件性能，因此使用全局对象来对索引变更的时机进行管理，通过互斥锁与读写锁来保证线程安全。
3. **容器化技术**：通过 Docker 容器来简化服务部署流程，主要位于emtm-server 仓库的 docker-compose.yml 与 Dockerfile 中。
4. **Future 异步模式**：主要位于 emtm-web 与 emtm-verify 中，使用异步模式来处理用户请求与向第三方服务器发送请求，使得软件产品可以以更低的开销，更少的资源获得更高的性能。由于 Rust 语言的 async 特性尚未稳定，我们使用的是 futures-rs 库来实现异步模式。
5. **MC架构模式**：在emtm-server仓库中，我们使用Model-Controller框架构建服务端，其中emtm-db负责数据库交互，emtm-web负责服务端逻辑业务。此种架构模式使得编程过程更加灵活，可扩展性更强，耦合度低，负责不同方向的同学可以并行完成工作。
